<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>webcore ▒ psychological web</title>
  <link rel="stylesheet" href="styles.css" />
  <style>
    :root { --bg:#000; --fg:#fff; }
    html,body{height:100%;margin:0}
    body{background:var(--bg);color:var(--fg);font:14px/1.5 ui-monospace,monospace;display:flex;flex-direction:column}
    .topbar{padding:12px 16px;font-weight:700}
    .blink{animation:blink 1s step-start infinite}@keyframes blink{50%{opacity:0}}
    main{flex:1;position:relative}
    #webCanvas{position:relative; z-index:0; width:100%;height:100%;display:block;background:#000}
    .controls{position:absolute;left:50%;bottom:20px;transform:translateX(-50%);display:flex;gap:8px;z-index:10}
    .controls input{padding:6px 10px;background:#111;color:#fff;border:1px solid #222;outline:none}
    .foot{text-align:center;padding:10px;color:#777}
    /* Side  panel */
    .sidepanel{position:absolute;top:12px;right:12px;width:260px;background:rgba(255,255,255,0.04);border:1px solid #1d1d1d;border-radius:6px;padding:10px;max-height:70vh;overflow:auto;z-index:20;pointer-events:auto}
    .side-title{color:#9aa;font-weight:700;margin:6px 0 8px}
    .card{border:1px solid #2a2a2a;padding:8px;margin:8px 0;cursor:pointer}
    .card:hover{background:rgba(255,255,255,0.05)}
    .badge{display:inline-block;border:1px solid #444;padding:2px 6px;font-size:12px;margin-right:6px}
    .btnrow{display:flex;gap:6px;margin-top:6px}
    .btn{border:1px solid #666;padding:4px 8px;background:#111;color:#eee;cursor:pointer}
    .btn:hover{background:#222}
  </style>
</head>
<body>
  <header class="topbar">
    <div class="mark">webcore <span class="blink">_</span></div>
  </header>

  <main>
    <canvas id="webCanvas"></canvas>

    <!-- Suggestions panel -->
    <aside id="sidepanel" class="sidepanel">
      <div class="side-title">// suggestions</div>
      <div id="sugCombos"></div>
      <div class="side-title">// quick probe</div>
      <div id="sugProbe"></div>
    </aside>

    <div class="controls">
      <input id="nameInput" placeholder="Enter name (press Enter or click canvas)" />
      <input id="traitInput" placeholder="Enter trait (press Enter, Shift+Enter = quick combo)" />
    </div>
  </main>

  <footer class="foot">@ webcore — 0.11</footer>

  <script>
  (function(){
    // =================== Canvas & sizing ===================
    var canvas = document.getElementById('webCanvas');
    var ctx = canvas.getContext('2d');
    function resize(){ canvas.width=window.innerWidth; canvas.height=window.innerHeight; ctx.font='14px monospace'; }
    resize();
    window.addEventListener('resize', function(){ resize(); redraw(); });

    // =================== Model =============================
var people=[], activePerson=null, lastAddedIdx=null;
var CENTER_HIT = 18;  // bigger center dot hit area
var NODE_HIT   = 12;  // bigger trait/red dot hit area


    function Person(name,x,y){
  this.name=name; this.x=x; this.y=y;
  this.traits=[]; this.generated=[];
  this.color = brightOrange(); // 👈 per-person label color
}


// Bright color helper (we’ll add a proper color picker later)
function brightOrange(){ return '#ff8a00'; } // default

    // --- helpers
    function posOf(p, node){ return { x: p.x + Math.cos(node.angle)*node.dist, y: p.y + Math.sin(node.angle)*node.dist }; }
    function angleAvg(a,b){ var x=Math.cos(a)+Math.cos(b), y=Math.sin(a)+Math.sin(b); return Math.atan2(y,x); }
    function goldenAngle(n){ return (n * 2.399963229728653) % (Math.PI*2); } // ~137.5°
    function nodePositions(p){ var pts=[], i; for(i=0;i<p.traits.length;i++) pts.push(posOf(p,p.traits[i])); for(i=0;i<p.generated.length;i++) pts.push(posOf(p,p.generated[i])); return pts; }
    function tooClose(pt, pts, min){ for(var i=0;i<pts.length;i++){ var dx=pt.x-pts[i].x, dy=pt.y-pts[i].y; if(Math.sqrt(dx*dx+dy*dy)<min) return true; } return false; }
    function findOpenSpot(p, baseAngle, dist){ var pts=nodePositions(p), step=Math.PI/18; for(var t=0;t<36;t++){ var a=baseAngle+t*step; var test={x:p.x+Math.cos(a)*dist, y:p.y+Math.sin(a)*dist}; if(!tooClose(test,pts,26)) return a; } return baseAngle; }

    // ---------  (no auto combos; smart placement) ---------
    Person.prototype.addTrait=function(trait){
      if(!trait) return -1;
      var n=this.traits.length, base=goldenAngle(n), ring=(n%8>=4)?1:0, dist=110+ring*50;
      var ang=findOpenSpot(this, base, dist);
      this.traits.push({ text:trait, angle:ang, dist:dist });
      return this.traits.length-1;
    };
    Person.prototype.isHit = function(mx,my){
  var dx = mx - this.x, dy = my - this.y;
  return Math.sqrt(dx*dx + dy*dy) <= CENTER_HIT; // was 15
};


    // =================== Persistence =======================
    function saveState(){
      var data = people.map(function(p){
        return {
          name:p.name, x:p.x, y:p.y,
          traits:p.traits.map(function(t){ return {text:t.text, angle:t.angle, dist:t.dist}; }),
          generated:p.generated.map(function(g){ return {text:g.text, angle:g.angle, dist:g.dist, from:g.from}; })
        };
      });
      try{ localStorage.setItem('webcore.v1', JSON.stringify(data)); }catch(e){}
    }
    function loadState(){
      var raw = localStorage.getItem('webcore.v1'); if(!raw) return;
      try{
        var arr = JSON.parse(raw);
        people = arr.map(function(p){
          var P = new Person(p.name, p.x, p.y);
          P.traits = (p.traits||[]).map(function(t){ return {text:t.text, angle:t.angle, dist:t.dist}; });
          P.generated = (p.generated||[]).map(function(g){ return {text:g.text, angle:g.angle, dist:g.dist, from:g.from}; });
          return P;
        });
      }catch(e){}
    }

    // =================== Suggestions =======================
    function traitPairs(p){ var out=[], n=p.traits.length; for(var i=0;i<n;i++) for(var j=i+1;j<n;j++) out.push([i,j]); return out; }
    function alreadyHasGen(p,i,j){
      for(var k=0;k<p.generated.length;k++){ var f=p.generated[k].from||[]; if(f.length<2) continue;
        if((f[0]===i && f[1]===j) || (f[0]===j && f[1]===i)) return true; }
      return false;
    }
    function scorePair(p,i,j){
      var tA=p.traits[i], tB=p.traits[j];
      var dx=Math.cos(tA.angle)*tA.dist - Math.cos(tB.angle)*tB.dist;
      var dy=Math.sin(tA.angle)*tA.dist - Math.sin(tB.angle)*tB.dist;
      var spatial = Math.sqrt(dx*dx+dy*dy);            // spacing heuristic
      var novelty = 1 + Math.random()*0.2;             // tie-breaker
      return spatial * novelty;
    }
    function proposeCombos(p, limit, onlyIdx){
      if(!p || p.traits.length<2) return [];
      var pairs=[], n=p.traits.length, i,j;
      for(i=0;i<n;i++) for(j=i+1;j<n;j++){
        if(onlyIdx!=null && !(i===onlyIdx || j===onlyIdx)) continue;
        if(alreadyHasGen(p,i,j)) continue;
        pairs.push([i,j]);
      }
      if(!pairs.length) return [];
      pairs.sort(function(a,b){ return scorePair(p,b[0],b[1]) - scorePair(p,a[0],a[1]); });
      return pairs.slice(0, limit||2);
    }

    function renderSuggestions(){
      var box = document.getElementById('sugCombos');
      var probe = document.getElementById('sugProbe');
      box.innerHTML=''; probe.innerHTML='';

      if(!activePerson){ box.innerHTML='<div class="card">Select or create a person</div>'; return; }


      // Active person header + delete button
      var head = document.createElement('div');
      head.className = 'card';
      head.style.display = 'flex';
      head.style.justifyContent = 'space-between';
      head.style.alignItems = 'center';
      head.innerHTML = '<span><span class="badge">active</span>' + activePerson.name + '</span>';
      var del = document.createElement('button');
      del.className = 'btn';
      del.style.borderColor = '#a33';
      del.style.color = '#f88';
      del.textContent = 'Delete person';
      del.onclick = function(){ if(confirm('Delete ' + activePerson.name + '?')) removePerson(activePerson); };
      head.appendChild(del);
      
      // Color cycle button (simple until we add a picker)
var col = document.createElement('button');
col.className = 'btn';
col.textContent = 'Change color';
col.onclick = function(){
  var hues = ['#ff8a00','#ff3860','#8a2be2','#00d1b2','#ffd166'];
  if (!activePerson.color) activePerson.color = '#ff8a00';
  var cur = hues.indexOf(activePerson.color);
  activePerson.color = hues[(cur+1+hues.length)%hues.length];
  saveState(); redraw(); renderSuggestions();
};
head.appendChild(col);

// (this line is already there after the delete button)
box.appendChild(head);

      box.appendChild(head);


      // Soft categories from text
function cat(tr){
  tr = (tr||'').toLowerCase();
  if (tr.match(/generous|kind|giving/))             return 'warmth';
  if (tr.match(/ambit|driven|domin|assert/))       return 'dominance';
  if (tr.match(/excus|blame|avoid/))               return 'avoidance';
  if (tr.match(/isolat|withdraw|lonely/))          return 'withdrawal';
  if (tr.match(/attent|perform|show|status/))      return 'attention';
  if (tr.match(/anx|fear|risk-averse/))            return 'anxiety';
  if (tr.match(/scarce|rare|last|fomo/))           return 'scarcity';
  return 'other';
}

// Pairing rules → label + strength
var COMBO_RULES = {
  'attention+dominance': { label:'status display',            w:2 },
  'avoidance+dominance': { label:'fragile ambition',          w:3 },
  'attention+withdrawal':{ label:'overcompensation in public',w:2 },
  'anxiety+scarcity':     { label:'panic scarcity response',   w:3 },
  'attention+warmth':     { label:'performative generosity',   w:2 },
  'avoidance+warmth':     { label:'soft exit seeking',         w:2 }
};

function comboMeaning(aText, bText){
  var A = cat(aText), B = cat(bText);
  var key = (A <= B ? A+'+'+B : B+'+'+A);
  var rule = COMBO_RULES[key];
  if (rule) return { text: rule.label + ' ('+A+'×'+B+')', w: rule.w };
  return { text: aText + ' × ' + bText, w: 1 };
}

      // Prefer combos that include the newest trait
      var picks = proposeCombos(activePerson, 2, lastAddedIdx);
      if(!picks.length) picks = proposeCombos(activePerson, 2, null);

      if(picks.length===0){
        var none = document.createElement('div');
        none.className='card'; none.textContent='No new combos right now — add more traits.';
        box.appendChild(none);
      } else {
        for(var i=0;i<picks.length;i++){
          (function(pair){
            var a = activePerson.traits[pair[0]], b = activePerson.traits[pair[1]];
            var label = (a.text + ' × ' + b.text);
            var card = document.createElement('div');
            card.className='card';
            card.innerHTML = '<span class="badge">combo</span>' + label;
            card.onclick = function(){
              var ang = angleAvg(a.angle, b.angle);
              // normalize wrap-around
              if (Math.abs(a.angle-b.angle) > Math.PI) { ang += Math.PI; }
              var dist = (a.dist + b.dist)/2 + 20;
             var m = comboMeaning(a.text, b.text);  // ← maps to a nicer label + weight
activePerson.generated.push({ text: m.text, angle: ang, dist: dist, from:[pair[0], pair[1]], w: m.w });

              saveState(); redraw(); renderSuggestions();
            };
            box.appendChild(card);
          })(picks[i]);
        }
      }

      // Quick probe buttons
      var row = document.createElement('div');
      row.className='btnrow';
      ['xxx','gaming','working'].forEach(function(opt){
        var b=document.createElement('button'); b.className='btn'; b.textContent=opt;
        b.onclick=function(){ if(!activePerson) return; lastAddedIdx = activePerson.addTrait('prefers: '+opt); saveState(); redraw(); renderSuggestions(); };
        row.appendChild(b);
      });
      probe.appendChild(row);
    }

    // =================== Interaction state =================
    var hover={type:null, person:null, index:-1}; // 'person'|'trait'|'gen'|null
    var dragging={type:null, person:null, index:-1, offx:0, offy:0};

    function mouse(e){ var r=canvas.getBoundingClientRect(); return {x:e.clientX-r.left, y:e.clientY-r.top}; }
    function hitTest(mx,my){
      for(var i=people.length-1;i>=0;i--){
        var p=people[i], j, pt, dx, dy;
        for(j=p.generated.length-1;j>=0;j--){ pt=posOf(p,p.generated[j]); dx=pt.x-mx; dy=pt.y-my; if(Math.sqrt(dx*dx+dy*dy)<=NODE_HIT) return {type:'gen', person:p, index:j}; }
for(j=p.traits.length-1;j>=0;j--){ pt=posOf(p,p.traits[j]); dx=pt.x-mx; dy=pt.y-my; if(Math.sqrt(dx*dx+dy*dy)<=NODE_HIT) return {type:'trait', person:p, index:j}; }

        if(p.isHit(mx,my)) return {type:'person', person:p, index:-1};
      }
      return {type:null, person:null, index:-1};
    }

    // =================== Draw ==============================
    function redraw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);

      for(var i=0;i<people.length;i++){
        var p=people[i];

        // center node
        ctx.fillStyle='#fff';
        ctx.beginPath(); ctx.arc(p.x,p.y,8,0,Math.PI*2); ctx.fill();
        if(p===activePerson || (hover.type==='person' && hover.person===p)){
          ctx.strokeStyle='#666'; ctx.beginPath(); ctx.arc(p.x,p.y,12,0,Math.PI*2); ctx.stroke();
        }
        // label on top with outline
ctx.lineWidth = 4;
ctx.strokeStyle = '#000';
ctx.strokeText(p.name, p.x + 12, p.y + 4);
ctx.lineWidth = 1;
ctx.fillStyle = p.color;            // 👈 use per-person color
ctx.fillText(p.name, p.x + 12, p.y + 4);


        // traits
        for(var t=0;t<p.traits.length;t++){
          var tn=p.traits[t], pt=posOf(p,tn);
          ctx.strokeStyle='#444'; ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(pt.x,pt.y); ctx.stroke();
          ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(pt.x,pt.y,6,0,Math.PI*2); ctx.fill();
          if(hover.type==='trait' && hover.person===p && hover.index===t){ ctx.strokeStyle='#888'; ctx.beginPath(); ctx.arc(pt.x,pt.y,9,0,Math.PI*2); ctx.stroke(); }
          ctx.fillText(tn.text, pt.x+10, pt.y);
        }

       // generated (red) — only to parent traits
for(var g=0; g<p.generated.length; g++){
  var gn=p.generated[g], pg=posOf(p,gn);

  if(gn.from && gn.from.length){
    ctx.strokeStyle='#c33';
    ctx.lineWidth = gn.w || 1;     // ← thickness by meaning (1–3)
    for(var k=0;k<gn.from.length;k++){
      var idx=gn.from[k], parent=p.traits[idx]; if(!parent) continue;
      var pp=posOf(p,parent);
      ctx.beginPath(); ctx.moveTo(pg.x,pg.y); ctx.lineTo(pp.x,pp.y); ctx.stroke();
    }
    ctx.lineWidth = 1;             // ← reset
  }

  ctx.fillStyle='#ff0040'; ctx.beginPath(); ctx.arc(pg.x,pg.y,6,0,Math.PI*2); ctx.fill();
  if(hover.type==='gen' && hover.person===p && hover.index===g){ ctx.strokeStyle='#c44'; ctx.beginPath(); ctx.arc(pg.x,pg.y,9,0,Math.PI*2); ctx.stroke(); }
  ctx.fillStyle='#ff0040'; ctx.fillText(gn.text, pg.x+10, pg.y);
}

      }
      canvas.style.cursor = hover.type ? 'pointer' : (dragging.type ? 'grabbing' : 'default');
    }

    // =================== Delete person =====================
    function removePerson(p){
      var idx = people.indexOf(p);
      if (idx > -1) {
        people.splice(idx, 1);
        if (activePerson === p) activePerson = people.length ? people[people.length-1] : null;
        saveState(); redraw(); renderSuggestions();
      }
    }

    // =================== Drag release (robust) =============
    function releaseDrag(){
      if (dragging && dragging.type){
        dragging.type = null; dragging.person = null; dragging.index = -1;
        saveState(); redraw();
      }
    }

    // =================== Inputs ============================
    var nameInput=document.getElementById('nameInput');
    var traitInput=document.getElementById('traitInput');

    nameInput.addEventListener('keydown', function(e){
      if(e.key==='Enter'){
        var nm=nameInput.value.trim(); if(!nm) return;
        var p=new Person(nm, canvas.width/2, canvas.height/2);
        people.push(p); activePerson=p; nameInput.value='';
        saveState(); redraw(); renderSuggestions();
      }
    });

    traitInput.addEventListener('keydown', function(e){
      if(e.key==='Enter' && activePerson){
        var t = traitInput.value.trim(); if(!t) return;
        var idx = activePerson.addTrait(t);
        lastAddedIdx = idx;
        traitInput.value = '';

        // Shift+Enter = quick accept the top 1 combo involving this new trait
        if (e.shiftKey){
          var picks = proposeCombos(activePerson, 1, idx);
          if (picks.length){
            var i=picks[0][0], j=picks[0][1];
            var A=activePerson.traits[i], B=activePerson.traits[j];
            var ang = angleAvg(A.angle, B.angle);
            if (Math.abs(A.angle-B.angle) > Math.PI) { ang += Math.PI; }
            var dist = (A.dist + B.dist)/2 + 20;
            var m2 = comboMeaning(A.text, B.text);
activePerson.generated.push({ text: m2.text, angle: ang, dist: dist, from:[i, j], w: m2.w });

          }
        }

        saveState(); redraw(); renderSuggestions();
      }
    });

    canvas.addEventListener('mousemove', function(e){
      var m=mouse(e);
      if(dragging.type){
        if(dragging.type==='person'){
          dragging.person.x = m.x - dragging.offx;
          dragging.person.y = m.y - dragging.offy;
        } else {
          var pr=dragging.person, dx=m.x-pr.x, dy=m.y-pr.y;
          var node = dragging.type==='trait' ? pr.traits[dragging.index] : pr.generated[dragging.index];
          node.angle = Math.atan2(dy,dx);
          node.dist  = Math.sqrt(dx*dx+dy*dy);
        }
        redraw(); return;
      }
      hover = hitTest(m.x,m.y);
      redraw();
    });

    canvas.addEventListener('mousedown', function(e){
      e.preventDefault();
      var m=mouse(e), h=hitTest(m.x,m.y);

      if(h.type){
        // QUICK DELETE: Alt/Option + click center
        if (h.type==='person' && (e.altKey)){
          if (confirm('Delete ' + h.person.name + '?')) removePerson(h.person);
          return;
        }

        activePerson=h.person;
        var idx=people.indexOf(h.person); if(idx>-1){ var pulled=people.splice(idx,1)[0]; people.push(pulled); }
        if(h.type==='person'){
          dragging.type='person'; dragging.person=h.person;
          dragging.offx=m.x-h.person.x; dragging.offy=m.y-h.person.y;
        } else {
          dragging.type=h.type; dragging.person=h.person; dragging.index=h.index;
        }
        saveState(); redraw(); renderSuggestions();
        return;
      }

      var nm=nameInput.value.trim();
      if(nm){
        var p2=new Person(nm, m.x, m.y); people.push(p2); activePerson=p2; nameInput.value='';
        saveState(); redraw(); renderSuggestions();
      }
    });

    // release on various paths
    window.addEventListener('mouseup', releaseDrag);
    canvas.addEventListener('mouseup', releaseDrag);
    document.addEventListener('mouseup', releaseDrag, true);
    canvas.addEventListener('mouseleave', releaseDrag);
    window.addEventListener('blur', releaseDrag);
    document.addEventListener('mousedown', function(e){
      if (!e.target.closest || !e.target.closest('#webCanvas')) releaseDrag();
    }, true);

    // Keyboard delete: Delete/Backspace (when not typing in inputs)
    document.addEventListener('keydown', function(e){
      var tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
      if (tag==='input' || tag==='textarea') return;
      if ((e.key==='Delete' || e.key==='Backspace') && activePerson){
        if (confirm('Delete ' + activePerson.name + '?')) removePerson(activePerson);
      }
    });

    // load, suggest, paint
    loadState(); renderSuggestions(); redraw();

    // (Optional) basic error catcher so we can see issues on-page if any arise
    window.addEventListener('error', function(ev){
      console.log('Webcore error:', ev.message, 'at', ev.filename+':'+ev.lineno+':'+ev.colno);
    });
  })();
  </script>
</body>
</html>
