<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>webcore ▒ psychological web</title>
<link rel="stylesheet" href="styles.css" />
</head>
<body>
<header class="topbar">
<div class="mark">webcore <span class="blink">_</span></div>
</header>


<main>
<canvas id="webCanvas"></canvas>
<div class="controls">
<input id="nameInput" placeholder="Enter name (click canvas to place)" />
<input id="traitInput" placeholder="Enter trait (hit enter to add)" />
</div>
</main>


<footer class="foot">@ webcore — 0.6</footer>


<script>
(function(){
  // canvas + sizing
  var canvas = document.getElementById('webCanvas');
  var ctx = canvas.getContext('2d');
  function resize(){ canvas.width=window.innerWidth; canvas.height=window.innerHeight; ctx.font='14px monospace'; }
  resize(); window.addEventListener('resize', function(){ resize(); redraw(); });

  // model
  var people=[], activePerson=null;
  function Person(name,x,y){ this.name=name; this.x=x; this.y=y; this.traits=[]; this.generated=[]; }

  // helper: polar -> cartesian relative to person center
  function posOf(p, node){ return { x: p.x + Math.cos(node.angle)*node.dist, y: p.y + Math.sin(node.angle)*node.dist }; }

  Person.prototype.addTrait=function(trait){
    if(!trait) return;
    this.traits.push({ text:trait, angle:Math.random()*Math.PI*2, dist:100+Math.random()*50 });
    // make a generated behavior from the last two traits & remember parents
    if(this.traits.length>1){
      var aIdx=this.traits.length-2, bIdx=this.traits.length-1;
      var prev=this.traits[aIdx].text;
      this.generated.push({ text: prev+' + '+trait, angle:Math.random()*Math.PI*2, dist:180, from:[aIdx,bIdx] });
    }
  };

  Person.prototype.isHit=function(mx,my){ var dx=mx-this.x,dy=my-this.y; return Math.sqrt(dx*dx+dy*dy)<=15; };

  // hover/drag state
  var hover={type:null, person:null, index:-1};      // type: 'person'|'trait'|'gen'|null
  var dragging={type:null, person:null, index:-1, offx:0, offy:0};

  // utils
  function mouse(e){ var r=canvas.getBoundingClientRect(); return {x:e.clientX-r.left, y:e.clientY-r.top}; }

  // hit-test (topmost first)
  function hitTest(mx,my){
    for(var i=people.length-1;i>=0;i--){
      var p=people[i], j, pt, dx, dy;
      // generated
      for(j=p.generated.length-1;j>=0;j--){
        pt=posOf(p,p.generated[j]); dx=pt.x-mx; dy=pt.y-my;
        if(Math.sqrt(dx*dx+dy*dy)<=9) return {type:'gen', person:p, index:j};
      }
      // traits
      for(j=p.traits.length-1;j>=0;j--){
        pt=posOf(p,p.traits[j]); dx=pt.x-mx; dy=pt.y-my;
        if(Math.sqrt(dx*dx+dy*dy)<=9) return {type:'trait', person:p, index:j};
      }
      // person
      if(p.isHit(mx,my)) return {type:'person', person:p, index:-1};
    }
    return {type:null, person:null, index:-1};
  }

  // draw
  function redraw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);

    for(var i=0;i<people.length;i++){
      var p=people[i];

      // center node
      ctx.fillStyle='#fff';
      ctx.beginPath(); ctx.arc(p.x,p.y,8,0,Math.PI*2); ctx.fill();
      if(p===activePerson || (hover.type==='person' && hover.person===p)){
        ctx.strokeStyle='#666'; ctx.beginPath(); ctx.arc(p.x,p.y,12,0,Math.PI*2); ctx.stroke();
      }
      ctx.fillText(p.name, p.x+12, p.y+4);

      // trait spokes + nodes
      for(var t=0;t<p.traits.length;t++){
        var tn=p.traits[t], pt=posOf(p,tn);
        ctx.strokeStyle='#444'; ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(pt.x,pt.y); ctx.stroke();
        ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(pt.x,pt.y,6,0,Math.PI*2); ctx.fill();
        if(hover.type==='trait' && hover.person===p && hover.index===t){ ctx.strokeStyle='#888'; ctx.beginPath(); ctx.arc(pt.x,pt.y,9,0,Math.PI*2); ctx.stroke(); }
        ctx.fillText(tn.text, pt.x+10, pt.y);
      }

      // generated spokes + parent links + nodes (red)
      for(var g=0; g<p.generated.length; g++){
        var gn=p.generated[g], pg=posOf(p,gn);
        // center → red
        ctx.strokeStyle='#800'; ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(pg.x,pg.y); ctx.stroke();
        // red → parents
        if(gn.from && gn.from.length){
          ctx.strokeStyle='#c33';
          for(var k=0;k<gn.from.length;k++){
            var idx=gn.from[k], parent=p.traits[idx]; if(!parent) continue;
            var pp=posOf(p,parent);
            ctx.beginPath(); ctx.moveTo(pg.x,pg.y); ctx.lineTo(pp.x,pp.y); ctx.stroke();
          }
        }
        // node + hover
        ctx.fillStyle='#ff0040'; ctx.beginPath(); ctx.arc(pg.x,pg.y,6,0,Math.PI*2); ctx.fill();
        if(hover.type==='gen' && hover.person===p && hover.index===g){ ctx.strokeStyle='#c44'; ctx.beginPath(); ctx.arc(pg.x,pg.y,9,0,Math.PI*2); ctx.stroke(); }
        ctx.fillStyle='#ff0040'; ctx.fillText(gn.text, pg.x+10, pg.y);
      }
    }
    canvas.style.cursor = hover.type ? 'pointer' : (dragging.type ? 'grabbing' : 'default');
  }

  // inputs
  var nameInput=document.getElementById('nameInput');
  var traitInput=document.getElementById('traitInput');

  // create by Enter (centered)
  nameInput.addEventListener('keydown', function(e){
    if(e.key==='Enter'){
      var nm=nameInput.value.trim(); if(!nm) return;
      var p=new Person(nm, canvas.width/2, canvas.height/2);
      people.push(p); activePerson=p; nameInput.value=''; redraw();
    }
  });

  // hover + drag
  canvas.addEventListener('mousemove', function(e){
    var m=mouse(e);
    if(dragging.type){
      if(dragging.type==='person'){
        dragging.person.x = m.x - dragging.offx;
        dragging.person.y = m.y - dragging.offy;
      } else {
        var pr=dragging.person, dx=m.x-pr.x, dy=m.y-pr.y;
        var node = dragging.type==='trait' ? pr.traits[dragging.index] : pr.generated[dragging.index];
        node.angle = Math.atan2(dy,dx); node.dist = Math.sqrt(dx*dx+dy*dy);
      }
      redraw(); return;
    }
    hover = hitTest(m.x,m.y); redraw();
  });

  canvas.addEventListener('mousedown', function(e){
    var m=mouse(e), h=hitTest(m.x,m.y);

    if(h.type){
      activePerson=h.person;
      var idx=people.indexOf(h.person); if(idx>-1){ var pulled=people.splice(idx,1)[0]; people.push(pulled); }
      if(h.type==='person'){
        dragging.type='person'; dragging.person=h.person;
        dragging.offx=m.x-h.person.x; dragging.offy=m.y-h.person.y;
      } else {
        dragging.type=h.type; dragging.person=h.person; dragging.index=h.index;
      }
      redraw(); return;
    }

    var nm=nameInput.value.trim();
    if(nm){
      var p2=new Person(nm, m.x, m.y); people.push(p2); activePerson=p2; nameInput.value=''; redraw();
    }
  });

  window.addEventListener('mouseup', function(){ dragging.type=null; dragging.person=null; dragging.index=-1; });

  // add trait by Enter
  traitInput.addEventListener('keydown', function(e){
    if(e.key==='Enter' && activePerson){
      var t=traitInput.value.trim(); if(!t) return;
      activePerson.addTrait(t); traitInput.value=''; redraw();
    }
  });

  // first paint
  redraw();
})();
</script>


